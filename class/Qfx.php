<?php

if(!$Qdatabase) exit; $keybase = file($Qdatabase.'/key.php'); $Qpassword_file = file($Qdatabase.'/psw.php'); if($Qidkey){ @session_start(); $x = hash('ripemd256', substr($Qidkey,0,32)); $y = hash('sha512', substr($Qidkey,32)); if(isset($_SESSION[$x])) $z = Qdecrypt($_SESSION[$x],$y,$Qaes256iv); else { $z = file_get_contents($Qserver.'index.php?TOKEN='.hash('ripemd256',$Qidkey)); $z = Qdecrypt($z,$Qidkey,$Qaes256iv); $_SESSION[$x] = Qcrypt($z,$y,$Qaes256iv); } $Qpassword_file[2] = Qdecrypt($Qpassword_file[2],$z,$Qaes256iv); } $Qpassword = explode('.',rtrim($Qpassword_file[2])); if(count($Qpassword) != 258) { header('location: class/updated.htm'); exit; }

class Qfx extends Qdb
{
    protected $orapsw = false, $pospsw = false;
    
    public static function time(){ global $Qgmt; return strtotime(gmdate("M d Y H:i:s", time())) + $Qgmt; }
    public static function dir($key=NULL, $val=NULL){ if($key && $val) { $val = Qfx::hashpos(Qhash($val), Qfx::combina($key)); if(file_exists("$val/index.php")) return $val; } return false; }
    public static function r($per=NULL){ if($per && file_exists($per)){ $l = filesize($per); if($l){ $f = fopen($per,'r'); if($f){ $h = fread($f,$l); fclose($f); return $h; }}} return false; }
    public static function a($file=NULL, $val=NULL){ if($file && $val){ if(is_array($val)) $val = implode('',$val); $f = fopen($file,'a+'); if($f){ fwrite($f,$val); fclose($f); return true; }} return false; }
    public static function w($file=NULL, $val=NULL){ if($file && $val){ if(is_array($val)) $val = implode('',$val); $f = fopen($file,'w+'); if($f){ fwrite($f,$val); fclose($f); return true; }} return false; }
    
    protected function _in($keys=NULL, $val=NULL, $valass=NULL, $opz=0) { return Qin::Qdbin($keys, $val, $valass, $opz); }
    protected function _out($keys=NULL, $valass=NULL, $opz=NULL, $type=0, $all=NULL) { return Qout::Qdbout($keys, $valass, $opz, $type, $all); }
    protected function _ver($keys=NULL, $val=NULL, $valass=NULL, $opz=NULL) { return Qver::Qdbver($keys, $val, $valass, $opz); }
    protected function _del($keys=NULL, $valass=NULL, $opz=NULL, $type=0) { return Qdel::Qdbdel($keys, $valass, $opz, $type); }
    protected function _elimina($keyper=NULL, $val=NULL, $opz=0, $ora=0) { return Qdel::elimina($keyper, $val, $opz, $ora); }
    protected function _directory($dir=NULL, $opz=0, $dirdel=0, $ora=0, $id=0, $keydel=0, $linkdel=0) { return Qdel::directory($dir, $opz, $dirdel, $ora, $id, $keydel, $linkdel); }
    protected function _scrivi($keyper=NULL, $orapsw=NULL, $posold=0, $opz=0, $type=0, $pos=0, $mod=0, $etc=0, $db=0) { return Qdel::scrivi($keyper, $orapsw, $posold, $opz, $type, $pos, $mod, $etc, $db); }
    protected function orapos($ora) { global $Qpassword; $this->pospsw = mt_rand(0,count($Qpassword)-3); if($this->pospsw < 16) $this->orapsw = $ora.'0'; else $this->orapsw = $ora; $this->orapsw .= dechex($this->pospsw); }
    
    protected static function u($val){ $val = array_filter($val,'strlen'); $val = array_unique($val); $val = array_values($val); return $val; }
    protected static function ch($keyper, $hash){ global $Qlivtime; for($a=0; $a<$Qlivtime; $a++) { $keyper .= '/'.substr($hash, $a*2, 2); Qfx::ix($keyper); } return $keyper.'/'.$hash; }
    protected static function lh($keyper, $hash){ global $Qlivtime; for($a=0; $a<$Qlivtime; $a++) { $keyper .= '/'.substr($hash, $a*2, 2); $per = $keyper.'/'.$hash; if(is_dir($per)) return $per; } return $per; }
    protected static function ix($keyper, $opz=false){ global $Qprotezione; $k = $keyper.'/index.php'; if(!file_exists($k)){ if($opz) $p = $Qprotezione.'0'; else $p = $Qprotezione; if(!is_dir($keyper)) mkdir($keyper,0755); Qfx::w($k,$p); } return $k; }
    protected static function countchars($val){ $l = mb_strlen($val, 'UTF-8'); $x = array(); for($a=0; $a<$l; $a++) { $y = mb_substr($val, $a, 1, 'UTF-8'); if(!isset($x[$y])) $x[$y] = 0; $x[$y]++; } $x = array_keys($x); rsort($x); return implode('',$x); }
    protected static function combina($key, $opz=0){ if(!$key) return false; global $Qdatabase; global $keybase; $verper = $Qdatabase; $key = explode('.', $key); $x = ''; $per = array(); $id = "\n"; if($key[0][0] == '#') { $key[0] = substr($key[0],1); $id = ".0\n"; } elseif($key[0][0] == '@') { $key[0] = substr($key[0],1); $id = ".1\n"; } for($a=0; $a<count($key); $a++) { $per[$a] = 0; $j = array_search($key[$a]."\n",$keybase); if($j > 1) { $x .= $j.'.'; $verper .= '/'.$j; if(is_dir($verper)) $per[$a] = $j; else return Qfx::error(0,0,$verper); } else return Qfx::error(0,1,$key[$a]); } if($opz == 1) return substr($x, 0, -1).$id; elseif($opz == 2) return $verper; else return $per; }
    protected static function trak($chiaro, $opz=0){ $chiaro = str_replace(array('?','!',';',',','"','(',')','[',']','{','}',"'","\n","\r"), ' ', $chiaro); $f = array_unique(explode(' ', $chiaro)); $a = 0; $x = false; foreach($f as $s) if(mb_strlen($s,'UTF-8') > 2 or is_numeric($s)) { $y = mb_substr($s,-1,1,'UTF-8'); if($y == '.' or $y == ':') $s = mb_substr($s,0,-1,'UTF-8'); if(mb_strpos($s,'@',0,'UTF-8') > 2) { $e = explode('@',$s); if($opz) { $x[$a] = $e[0]; $a++; $x[$a] = $e[1]; $a++; } else { $x[$a] = Qfx::countchars($e[0]); $a++; $x[$a] = Qfx::countchars($e[1]); $a++; }} if(mb_strpos($s,'/',0,'UTF-8') !== false) { $e = explode('/',$s); foreach($e as $z) if(strlen($z) > 0) { if($opz) $x[$a] = $z; else $x[$a] = Qfx::countchars($z); $a++; }} if($opz) $x[$a] = $s; else $x[$a] = Qfx::countchars($s); $a++; } if($x) { $f = array_unique($x); sort($f); return $f; } else return false; }
    protected static function Qsort($val) { if(is_array($val)) { $x = array(); $y = array(); $z = array(); $s = array(); foreach($val as $v) { if($v[0] == '#') $y[] = $v; elseif($v[0] == '@') $z[] = $v; elseif(strpos($v,' ') > 1) $s[] = $v; elseif(strpos($v,'{') > 1) $x[] = substr($v,0,strpos($v,'{')); else $x[] = $v; } return array_merge($x,$y,$z,$s); } else return $val; }
    protected static function ordina($key, $array, $opz=0){ $low = 2; $high = count($array) - 1; if($opz) { while ($low <= $high) { $mid = floor(($low + $high) / 2); $val = rtrim($array[$mid]); if($val <= $key) $low = $mid + 1; else $high = $mid - 1; } return $high; } else { while ($low <= $high) { $mid = floor(($low + $high) / 2); $val = rtrim($array[$mid]); if($val >= $key) $high = $mid - 1; else $low = $mid + 1; } return $low; }}
    protected static function binary($key, $array, $opz, $low=2){ $high = count($array)-1; if($opz) { while ($low <= $high) { $mid = floor(($low + $high) / 2); $val = substr($array[$mid],0,10); if($val <= $key) $low = $mid + 1; else $high = $mid - 1; } return $high; } else { while ($low <= $high) { $mid = floor(($low + $high) / 2); $val = substr($array[$mid],0,10); if($val >= $key) $high = $mid - 1; else $low = $mid + 1; } return $low; }}
    protected static function hashpos($hash, $per, $opz=0){ global $Qdatabase; $keyper = $Qdatabase; if($opz > 1000) $keyper .= '/@'; foreach($per as $corso) $keyper .= '/'.$corso; $keyper = Qfx::lh($keyper,$hash); return $keyper; }
    protected static function speciali($val, $opz=0){ if($opz) { if(is_array($val)) return $val; else { if($val === false or strtolower($val) == 'false') $val = 'false'; elseif($val === true or strtolower($val) == 'true') $val = 'true'; elseif($val == 0) $val = (string)$val; return $val; }} if($val[10] == 't') return 'true'; elseif($val[10] == 'f') return 'false'; }
    protected static function isnumber($val){ if(strstr($val,'.')){ if(filter_var($val, FILTER_VALIDATE_IP)) return true; } else { if(is_numeric($val) && $val > 0) return true; } return false; }
    protected static function prcnumber(){ global $QprcNumber; global $Qlivtime; if($QprcNumber[0]) return $QprcNumber[0]; else return $QprcNumber[$Qlivtime]; }
    protected static function keyval($orapsw, $keyval, $val){ if($orapsw == substr($keyval,0,12)) return substr($keyval,12); else return Qfx::recupero($val); }
    protected static function cancella($array, $item){ if(isset($array[$item])) unset($array[$item]); return array_merge($array); }
    protected static function keyvalass($keyass, $valass, $per, $stat=0, $opz=0){ $hash = Qhash($valass); $x = 0; $keyval = false;
        if($stat == 2) { $keyass = Qfx::lh($keyass, $hash); $comb = $keyass.'/keys.php'; $link = $keyass.'/link.php'; if(file_exists($comb)){ $fcomb = file($comb); $flink = file($link); if(is_array($opz)) { foreach($per as $key) { $j = array_search($opz[$x],$fcomb); $x++; if($j > 1) $keyval[$key] = $flink[$j]; else $keyval[$key] = false; } return $keyval; } else $x = array_search($per,$fcomb); } else if(is_array($opz)) { foreach($per as $key) $keyval[$key] = false; return $keyval; }} else { if(strlen($opz) > 64) $hashpos = $opz; else $hashpos = Qfx::hashpos($hash, Qfx::combina($keyass)); if($hashpos) { $comb = $hashpos.'/keys.php'; $link = $hashpos.'/link.php'; $riga = $per[0]; $dir = '.'.$per[0]; for($a=1; $a<count($per); $a++) { $riga .= '.'.$per[$a]; $dir .= '/'.$per[$a]; } if(file_exists($comb)){ $fcomb = file($comb); $x = array_search($riga."\n",$fcomb); }}}
        if($x > 1) { $flink = file($link); 
            if($stat == 1) { $f = file($hashpos.'/index.php'); $del = $flink[$x]; $chiaro = mb_strtolower(trim(Qfx::val($del)),'UTF-8'); $hash = Qhash($chiaro); $hashpos = Qfx::combina($keyass,2).'/'.$dir; $key = $hashpos; $hashpos = Qfx::lh($hashpos,$hash); $keyass = $hashpos.'/index.php'; $hashpos .= '/idem.php';
                if(file_exists($hashpos)){ $h = file($hashpos); $j = array_search($f[2],$h); if($j > 1) { $h = Qfx::cancella($h,$j); Qfx::w($hashpos,$h); } $h = file($keyass); $h[2]--; Qfx::w($keyass,$h);
                    if(is_numeric($chiaro)) { $hashpos = $key.'/list.php';
                        if(file_exists($hashpos)){ $h = file($hashpos); $f = explode('#',$h[2]); if($chiaro == $f[0]) { $fn = file($key.'/n2.php'); if(isset($fn[2])) { if($fn[2] == "1\n") { $fv = file($key.'/v2.php'); $f[2] = (int)$f[2] - 1; if($f[2] > 0) $h[2] = rtrim($fv[3]).'#'.$f[1].'#'.$f[2]."\n"; else $h[2] = $f[1].'#'.$f[1].'#'.$f[2]."\n"; $fn = Qfx::cancella($fn,2); $fv = Qfx::cancella($fv,2); Qfx::w($key.'/n2.php',$fn); Qfx::w($key.'/v2.php',$fv); } else { if($j > 1) { $f[2] = (int)$f[2] - 1; $h[2] = $f[0].'#'.$f[1].'#'.$f[2]."\n"; $fn[2] = ((int)$fn[2] - 1)."\n"; Qfx::w($key.'/n2.php',$fn); }}}
                            } else { $pos = count($h); $min = $pos - 1; $f = explode('#',$h[$min]); if($chiaro == $f[1]) { $fn = file($key.'/n'.$min.'.php'); if($fn[count($fn)-1] == "1\n") { if(count($fn) > 3) { $fv = file($key.'/v'.$min.'.php'); $f[2] = (int)$f[2] - 1; $h[$min] = $f[0].'#'.rtrim($fv[count($fv)-2]).'#'.$f[2]."\n"; array_pop($fn); array_pop($fv); Qfx::w($key.'/n'.$min.'.php',$fn); Qfx::w($key.'/v'.$min.'.php',$fv); } else { array_pop($h); unlink($key.'/n'.$min.'.php'); unlink($key.'/v'.$min.'.php'); }}
                            } else { for($b=2; $b<$pos; $b++){ $f = explode('#',$h[$b]); if($chiaro >= $f[0] and $chiaro <= $f[1]) { if($f[2] > 0) { $f[2] = (int)$f[2] - 1; $h[$b] = $f[0].'#'.$f[1].'#'.$f[2]."\n"; $fn = file($key.'/n'.$b.'.php'); $fv = file($key.'/v'.$b.'.php'); $j = array_search($chiaro."\n",$fv); if($j > 1) { $fn[$j] = (int)$fn[$j] - 1; if($fn[$j] < 1) { $fn = Qfx::cancella($fn,$j); $fv = Qfx::cancella($fv,$j); Qfx::w($key.'/v'.$b.'.php',$fv); } else $fn[$j] .= "\n"; Qfx::w($key.'/n'.$b.'.php',$fn); }} break; }}}} Qfx::w($hashpos,$h); 
                        } else Qfx::error(3,0,$hashpos); 
                    }
                } $dir = array(); $t = Qfx::trak($chiaro); $s = $t[0][0]; $str[0] = $t[0]; $a = 0; for($b=1; $b<count($t); $b++) { if($s == $t[$b][0]) $str[$a] .= $t[$b]; else { $dir[] = Qord($str[$a]); $a++; $s = $t[$b][0]; $str[$a] = $t[$b]; }} $dir[] = Qord($str[$a]);
                for($a=0; $a<count($dir); $a++) { $ftraccia = $key.'/'.$dir[$a].'/keyt.php'; $fstato = $key.'/'.$dir[$a].'/stat.php'; $fcript = $key.'/'.$dir[$a].'/keyc.php'; $findex = $key.'/'.$dir[$a].'/keyi.php';
                    if(file_exists($fcript)){ $ftc = file($fcript); $j = array_search($del,$ftc); if($j > 1) { $ftr = file($ftraccia); $fts = file($fstato); $fti = file($findex); $ftr = Qfx::cancella($ftr,$j); $fts = Qfx::cancella($fts,$j); $ftc = Qfx::cancella($ftc,$j); $fti = Qfx::cancella($fti,$j); Qfx::w($ftraccia,$ftr); Qfx::w($fstato,$fts); Qfx::w($fcript,$ftc); Qfx::w($findex,$fti); }}
                } if($opz == 0) { $flink = Qfx::cancella($flink, $x); $fcomb = Qfx::cancella($fcomb, $x); Qfx::w($link, $flink); Qfx::w($comb, $fcomb); } elseif($opz == 1) { $flink[$x] = $opz; Qfx::w($link, $flink); } return true; 
            } else return rtrim($flink[$x]); 
        } return false;
    }
    protected static function val($val, $key=0){ global $Qdatabase; global $Qpassword; global $Qpostime; global $Qposdef;
        if(is_array($key)) { $op = array(); $keytmp = false; foreach($val as $k) { if($k[0] != '#' and $k[0] != '@') { foreach($key[$k] as $v) { if(isset($v[11])) { if($v[10] == ':') $keytmp[$k][] = rtrim(substr($v,11)); else { if($v[11] == "\n") $keytmp[$k][] = Qfx::speciali($v); else { $x = substr($v,0,3); $y = substr($v,3,$v[12]); $z = $x.$y; $psw = $Qpassword[hexdec(substr($v,10,2))]; $orapsw = substr($v,0,12); $iv = Qiv($orapsw,$psw); if(in_array($z,$op)) { $keyval = Qdecrypt($file[$z][substr($v,13,-1)],$psw,$iv); $keytmp[$k][] = Qfx::keyval($orapsw,$keyval,$v); } else { $keyperindex = $Qdatabase.$Qpostime.'/'.$x.'/'.$y.'/index.php'; if(file_exists($keyperindex)){ $file[$z] = file($keyperindex); $op[] = $z; $keyval = Qdecrypt($file[$z][substr($v,13,-1)],$psw,$iv); $keytmp[$k][] = Qfx::keyval($orapsw,$keyval,$v); } else $keytmp[$k][] = false; }}}} else $keytmp[$k][] = false; }}} return $keytmp; } 
        if(is_array($val)) { $op = array(); $keytmp = false; foreach($val as $v){ if(isset($v[11])) { if($v[10] == ':') $keytmp[] = rtrim(substr($v,11)); else { if($v[11] == "\n") $keytmp[] = Qfx::speciali($v); else { $x = substr($v,0,3); $y = substr($v,3,$v[12]); $z = $x.$y; $psw = $Qpassword[hexdec(substr($v,10,2))]; $orapsw = substr($v,0,12); $iv = Qiv($orapsw,$psw); if(in_array($z,$op)) { $keyval = Qdecrypt($file[$z][substr($v,13,-1)],$psw,$iv); $keytmp[] = Qfx::keyval($orapsw,$keyval,$v); } else { $keyperindex = $Qdatabase.$Qpostime.'/'.$x.'/'.$y.'/index.php'; if(file_exists($keyperindex)){ $file[$z] = file($keyperindex); $op[] = $z; $keyval = Qdecrypt($file[$z][substr($v,13,-1)],$psw,$iv); $keytmp[] = Qfx::keyval($orapsw,$keyval,$v); } else $keytmp[] = false; }}}} else $keytmp[] = false; } return $keytmp; }
        else { if($val[10] == ':') return rtrim(substr($val,11)); if($val[11] == "\n") return Qfx::speciali($val); $keyperindex = $Qdatabase.$Qpostime.'/'.substr($val,0,3).'/'.substr($val,3,$val[12]).'/index.php'; if(file_exists($keyperindex)){ $str = file($keyperindex); $psw = $Qpassword[hexdec(substr($val,10,2))]; $orapsw = substr($val,0,12); $iv = Qiv($orapsw,$psw); $keyval = Qdecrypt($str[substr($val,13,-1)],$psw,$iv); return Qfx::keyval($orapsw,$keyval,$val); }} return false; 
    }
    protected static function leggi($keyper, $opz=0, $num=0, $type=0, $val=0){ global $Qposdef; global $Qposmax; $fp = false; $fstart = 0; $ntmp = 0; $y = 0; $z = 2; // con num[0] = 12 restituisco (10) risultati          $fp[0] = [T] - $fp[1] = [N]
        if($opz) { $QprcNum = Qfx::prcnumber(); if($type) $n = floor((int)substr($opz,1,10)/$QprcNum); else $n = floor((int)substr($opz,0,10)/$QprcNum); $keypert = "$keyper/t$n.php"; $keyper .= "/l$n.php"; if(file_exists($keyper)){ $fk = file($keyper); if($val) { foreach($fk as $j) if($j == $opz) $num++; return $num; } else { $j = array_search($opz, $fk); if($j > 1) { if($num) { $fk = file($keypert); return rtrim($fk[$j]); } else return $j-1; }}} return false; } $keyperindex = "$keyper/in.php"; if(file_exists($keyperindex)) { $l = Qfx::r($keyperindex); if($l){ $kn = explode('.',$l); $fstart = $kn[0]; $keyval[0] = $kn[2]; $keyval[1] = 0; $ntot = $kn[1]; } else return false; } else return false;
        if(isset($num[7])) { if(strstr($num[7],'-')) { $tot = Qfx::tot($keyper); $d = explode(':', $num[7]); if(count($d) == 1) { $num[6] = 1; $num[2] = $tot - 1; if($num[7] == '-') $num[0] = $tot - $Qposdef; elseif($num[7] == '-0') $num[0] = $tot - $Qposmax; else $num[0] = $tot + $num[7]; if($num[0] < 0) $num[0] = 0; $num[0] += 2; } elseif(count($d) == 2) { if($d[0] < 0 and $d[1] < 0) { $num[2] = $tot + $d[0]; $num[0] = $tot + $d[1]; if($num[0] < 0) $num[0] = 0; if($num[2] < 0) $num[2] = 0; $d[1] = $num[0]; $d[0] = $num[2]; $num[0] += 2; } elseif($d[0] < 0) { $num[2] = $tot + $d[0]; $num[0] = $d[1] + 2; if($num[2] < 0) $num[2] = 0; $d[0] = $num[2]; } else { $num[2] = $d[0]; $num[0] = $tot + $d[1]; if($num[0] < 0) $num[0] = 0; $d[1] = $num[0]; $num[0] += 2; } if($d[0] > $d[1]) $num[6] = true; } else return false; }}
        if($num[0] == '') $num[0] = $Qposdef + 2; if($num[6]) { $opz = $num[2] + 2; $num[2] = $num[0] - 2; $num[0] = $opz; if($num[2] > $num[0]) $num[2] = 0; } if($num[3]) { $keyperindex = $keyper.'/index.php'; if(file_exists($keyperindex)){ $fk = file($keyperindex); $par = 2; $arr = count($fk)-1; for($a=count($fk)-2; $a>1; $a--) { $k = explode('.', $fk[$a]); if($num[4] < $k[0]) { $a--; $arr = $a; } else { if($num[3] >= $k[0] and $num[3] <= $k[1]) $par = $a; if($num[4] >= $k[0] and $num[4] <= $k[1]) $arr = $a; if($num[3] > $k[1]) { $par = $a+1; break; }}} $fp = Qfx::trovatempo($keyper, $par, $arr, $num[3], $num[4], $num[2], $num[0], $num[5], $type, $val); if($num[6]) { if($fp[1]) { $keyval[1] = $fp[1]; for($c=$fp[1]+1; $c>1; $c--) $keyval[] = $fp[$c]; return $keyval; } else return false; } else { if($fp[1]) { $fp[0] = $kn[2]; return $fp; } else return false; }}}
        if($num[2] > $kn[2] or $kn[2] == 0) { $keyval[1] = 0; return $keyval; } if($num[2] > 0) { $num[0] -= $num[2] + 1; $keyperindex = $keyper.'/index.php'; if(file_exists($keyperindex)){ $fk = file($keyperindex); if($ntot == 0) { $num[0] += 2; $z = 1; } if($num[2] < $ntot) { if($num[3]) $fstart = $k[0]; else $fstart = $kn[0]; } else { for($a=count($fk)-$z; $a>1; $a--) { $k = explode('.', $fk[$a]); if(count($k) > 2) { $ntmp = $ntot; $ntot += $k[2]; if($num[2] < $ntot) { $fstart = $a; break; }} else $fstart = $a; }}}} if($num[0] == -1) { $fstart = $kn[0]; $num[0] = $kn[2] + 2; } else $num[0] += $num[2] - $ntmp; if($num[2] == -1) $num[2] = 0; if($num[2] == 0) $num[0]++; $opz -= 2; $k = 2;
        for($a=$fstart; $a>1; $a--) { if($type) $keypos = $keyper.'/v'.$a.'.php'; else $keypos = $keyper.'/'.$a.'.php'; if(file_exists($keypos)) { $fx = file($keypos); $n = count($fx); $tmp = $num[0]; $num[0] -= $n - 2; if($type == 2) { $ff = file($keyper.'/'.$a.'.php'); for($x=2; $x<$n; $x++) $fx[$x] = rtrim($fx[$x]).'.'.$ff[$x]; } if($val) { $fc = file($keyper.'/c'.$a.'.php'); if($val == 2) $ft = file($keyper.'/'.$a.'.php'); for($x=2; $x<count($fx); $x++) { $fx[$x] .= '.'.rtrim($fc[$x]); if($val == 2) $fx[$x] .= '.'.$ft[$x]; else $fx[$x] .= ".\n"; }} $y = $num[2] - $ntmp; if($y > 0) $w = $n - $tmp - 1; else $w = $n - $tmp + 1; if($w < 1) $w = 1; if($tmp < 0) break; else { for($b=$n-1; $b>$w; $b--) $fp[] = $fx[$b]; }}} if(!$fp) return false;
        if($num[6]) { $d = count($fp); if(($opz-$keyval[0]) > $Qposmax) { $keyval[1] = 0; return $keyval; } if(($opz-$num[2]) > $Qposmax) { $y = $d-$Qposmax-1; if($opz >= $keyval[0]) $y += $opz - $keyval[0] + 2; } else $y = $num[2]; for($c=$d-1; $c>($y-1); $c--) { $keyval[$k] = $fp[$c]; $k++; }} else $keyval = array_merge($keyval,array_slice($fp,$y)); $keyval[1] = count($keyval)-2; if($keyval[1] > $Qposmax) { array_splice($keyval,$Qposmax+2); $keyval[1] = $Qposmax; } return $keyval;
    }
    protected static function trovatempo($keyper, $par, $arr, $min, $max, $inizio, $fine, $opz, $type, $val){ $n = 2; $s = 0; $fp = false; if($inizio == -1) $fine--;
        if($opz) { for($a=$arr; $a>=$par; $a--) { $keypos = $keyper.'/'.$a.'.php'; if(file_exists($keypos)){ $fx = file($keypos); 
            if($type) { $keypos = $keyper.'/v'.$a.'.php'; if(file_exists($keypos)) $fv = file($keypos); else { $fp[0] = 1; $fp[1] = $n - 2; return $fp; } if($type == 2) for($x=2; $x<count($fx); $x++) $fv[$x] = rtrim($fv[$x]).'.'.$fx[$x]; }
            if($val) { $ff = file($keyper.'/c'.$a.'.php'); for($x=2; $x<count($ff); $x++) $fv[$x] .= '.'.rtrim($ff[$x]).'.'.$fx[$x]; } 
            if($a == $arr) $inz = Qfx::binary($max, $fx, 1); else $inz = count($fx)-1; for($b=$inz; $b>1; $b--) { $f = substr($fx[$b],0,10); if($f >= $min) { $s++; if($s > $inizio) { if($s == $fine) { $fp[0] = 1; $fp[1] = $n - 2; return $fp; } if($type) $fp[$n] = $fv[$b]; else $fp[$n] = $fx[$b]; $n++; }}}}}
        } else { for($a=$par; $a<=$arr; $a++) { $keypos = $keyper.'/'.$a.'.php'; if(file_exists($keypos)){ $fx = file($keypos); 
            if($type) { $keypos = $keyper.'/v'.$a.'.php'; if(file_exists($keypos)) $fv = file($keypos); else { $fp[0] = 1; $fp[1] = $n - 2; return $fp; } if($type == 2) for($x=2; $x<count($fx); $x++) $fv[$x] = rtrim($fv[$x]).'.'.$fx[$x]; }
            if($val) { $ff = file($keyper.'/c'.$a.'.php'); for($x=2; $x<count($ff); $x++) $fv[$x] .= '.'.rtrim($ff[$x]).'.'.$fx[$x]; } 
            if($a == $par) $inz = Qfx::binary($min, $fx, 0); else $inz = 2; for($b=$inz; $b<count($fx); $b++) { $f = substr($fx[$b],0,10); if($f <= $max) { $s++; if($s > $inizio) { if($s == $fine) { $fp[0] = 1; $fp[1] = $n - 2; return $fp; } if($type) $fp[$n] = $fv[$b]; else $fp[$n] = $fx[$b]; $n++; }}}}}
        } $fp[0] = 1; $fp[1] = $n - 2; return $fp;
    }
    protected static function tot($per){ $per .= '/in.php'; if(file_exists($per)) { $l = Qfx::r($per); if($l) { $l = explode('.',$l); return $l[2]; }} return 0; }
    protected static function error($type, $id, $val=NULL, $valass=NULL, $key=NULL, $keyass=NULL){ if($val[0] == '#') $val = Qfx::val(substr($val,1)."\n");
        $Qdb[0] = 'Qkey ERROR | :::'; $Qdb[1] = 'Qin ERROR | :::'; $Qdb[2] = 'Qout ERROR | :::'; $Qdb[3] = 'Qdel ERROR | :::'; $Qdb[4] = 'Qver ERROR | :::';
        $msg[0] = "$Qdb[$type] File Not Found ::: | $val";
        $msg[1] = "$Qdb[$type] Not Found ::: | $val";
        $msg[2] = "$Qdb[$type] Not be Entered because it is Lower than the Other Values ::: | $val";
        $msg[3] = "$Qdb[$type] The Value is an Array ::: | $val";
        $msg[4] = "$Qdb[$type] This KEY is an Array ::: |";
        $msg[5] = "$Qdb[$type] The Value KEY Not Exist ::: | $val";
        $msg[6] = "$Qdb[$type] $val ::: | The Value of this Multiple KEY can Only be Numeric or Alhanumeric !!! NO MIX !!!";
        $msg[7] = "$Qdb[$type] The Primary KEY ---> $keyass: $valass ---> already has the associated table ---> $key: $val ::: |";
        $msg[8] = "$Qdb[$type] has two possible solutions: NOTHING or an Array (KEY => value) ::: | #$val";
        $msg[9] = "$Qdb[$type] The Value of KEY is Not Entered ::: | $val";
        $msg[10] = "$Qdb[$type] KEY in the Array can Not be Numeric ::: |";
        $msg[11] = "$Qdb[$type] The Value of KEY is Not Correctly ::: | $val";
        $msg[12] = "$Qdb[$type] $val ---> Can Only have Numeric Values possibly with Automatic ID using the command Qin::Qdbin(\'#$val\') ::: |";
        $msg[13] = "$Qdb[$type] $val ---> This KEY is not present in this File: $valass ::: |";
        $msg[20] = "$Qdb[$type] Protect KEY Database is INCORRECT ::: |";
        $msg[21] = "$Qdb[$type] Synchronization Incorrect or Subscription Upgrade ::: |";
        $ora = Qfx::time(); Qfx::a('Quantico_errors.log', date('[d-M-Y H:i:s',$ora).' UTC] '.$msg[$id].chr(13).chr(10)); return false;
    }
    protected static function recupero($val){ global $Qdatabase; global $Qpassword; global $Qpostime; global $Qidkey; $keyper = $Qdatabase.$Qpostime.'/'.substr($val, 0, 3).'/'.substr($val, 3, $val[12]);
        if($Qidkey) { $keyperindex = $keyper.'/index.php'; $keyper .= '/sync.php'; $fp = file($keyperindex); $fx = file($keyper); $pos = substr($val, 13, -1); $key = $Qpassword[hexdec(substr($val, 10, 2))]; $orapsw = substr($val, 0, 12); $iv = Qiv($orapsw, $key); $v = Qdecrypt($fx[$pos], $key, $iv);
            if($orapsw == substr($v, 0, 12)) { if(count($fp) < count($fx)) array_splice($fp, $pos, 0, $fx[$pos]); else $fp[$pos] = $fx[$pos]; Qfx::w($keyperindex,$fp); $msg = 'SUCCESS'; } else $msg = 'FAILED'; Qfx::a('Quantico_errors.log', date('[d-M-Y H:i:s',time()).' UTC] AUTO Recovery <<< '.$msg.' >>> Encrypted File Corrupt: Position ('.$pos.') & File: '.$keyperindex.chr(13).chr(10));
        } else Qfx::a('Quantico_errors.log', date('[d-M-Y H:i:s',time()).' UTC] MANUAL Recovery - Encrypted File Corrupt: Position ('.substr($val, 12, -1).') & File: '.$keyper.'/index.php'.chr(13).chr(10)); return false;
    }
}

function Qord($val){ $ord0 = ord($val); if($ord0 >= 0 && $ord0 <= 127) return $ord0; if(!isset($val[1])) return false; $ord1 = ord($val[1]); if($ord0 >= 192 && $ord0 <= 223) return ($ord0-192)*64 + ($ord1-128); if(!isset($val[2])) return false; $ord2 = ord($val[2]); if($ord0 >= 224 && $ord0 <= 239) return ($ord0-224)*4096 + ($ord1-128)*64 + ($ord2-128); if(!isset($val[3])) return false; $ord3 = ord($val[3]); if($ord0 >= 240 && $ord0 <= 247) return ($ord0-240)*262144 + ($ord1-128)*4096 + ($ord2-128)*64 + ($ord3-128); if(!isset($val[4])) return false; $ord4 = ord($val[4]); if($ord0 >= 248 && $ord0 <= 251) return ($ord0-248)*16777216 + ($ord1-128)*262144 + ($ord2-128)*4096 + ($ord3-128)*64 + ($ord4-128); if(!isset($val[5])) return false; if($ord0 >= 252 && $ord0 <= 253) return ($ord0-252)*1073741824 + ($ord1-128)*16777216 + ($ord2-128)*262144 + ($ord3-128)*4096 + ($ord4-128)*64 + (ord($val[5])-128); if($ord0 >= 254 && $ord0 <= 255) return false; }
function Qsid($key){ global $Qpostime; if(is_array($key)) { $sid = Qfx::time(); foreach($key as $a) $sid .= $a; $sid = Qrawenc(md5($sid).$sid,$Qpostime); return $sid; } else { if(strlen($key) > 31) { $sid = Qrawdec($key,$Qpostime); $md5 = substr($sid,0,32); $sid = substr($sid,32); if($md5 == md5($sid)) { $array[0] = substr($sid,0,10); $array[1] = substr($sid,10,16); if(strlen($sid) > 26) $array[2] = substr($sid,26); return $array; }}} return false; }
function Qgp($x = 0,$y = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',$p = '') { $i = 0; while($i < $x) { $z = substr($y,mt_rand(0,strlen($y)-1),1); if(!strstr($p,$z)) { $p .= $z; $i++; }} return $p; }
function Qdecrypt($str, $key, $iv = false){ if(!$iv) { global $Qaes256iv; $iv = $Qaes256iv; } return @openssl_decrypt(base64_decode($str), 'aes-256-ctr', $key, OPENSSL_RAW_DATA, $iv); }
function Qcrypt($str, $key, $iv = false){ if(!$iv) $iv = Qiv(substr($str, 0, 12), $key); return base64_encode(@openssl_encrypt($str, 'aes-256-ctr', $key, OPENSSL_RAW_DATA, $iv)); }
function Qiv($str, $key){ global $Qaes256iv; return substr(openssl_encrypt(md5((string)$str), 'aes-256-ctr', $key, OPENSSL_RAW_DATA, $Qaes256iv), 0, 16); }
function Qhash($val){ global $Qpassword; return hash('ripemd256', $Qpassword[256].$val.$Qpassword[257]); }          
function Qrawdec($str, $key){ return Qdecrypt(rawurldecode($str), $key); }
function Qrawenc($str, $key){ return rawurlencode(Qcrypt($str, $key)); }

?>